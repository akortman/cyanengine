#include "ecs_script.hpp"

#include <string>

#include "cyan/generated/components/components.hpp"
#include "cyan/generated/components/components_x_list.hpp"

using namespace std::string_literals;
using namespace cyan;
using namespace cyan::component;

/**
 * Small utility to convert from PascalCase (or camelCase) to snake_case. Used to format component names for chai
 * functions.
 * @param name The name of the component (in PascalCase) to convert
 * @return The name in snake_case
 */
std::string format_component_name(char* name) {
    std::size_t pos = 0;
    std::string result;
    while (name[pos] != '\0') {
        if (pos == 0 && std::isupper(name[pos])) {
            result += std::tolower(name[pos]);
        } else if (std::isupper(name[pos])) {
            result += "_";
            result += std::tolower(name[pos]);
        } else {
            result += name[pos];
        }

        pos += 1;
    }

    return result;
}

void cyan::chai_add_ecs_library(cyan::ChaiEngine& chai_engine, cyan::ECS& ecs_object)
{
    // TODO: Ideally this would all be in an "ecs" namespace. However, that doesn't seem to want to compile.
    auto& chai = chai_engine.get_chai_object();
    chaiscript::ModulePtr m = chaiscript::ModulePtr(new chaiscript::Module());

    chaiscript::utility::add_class<Entity>(
            *m,
            "Entity",
            {chaiscript::constructor<Entity()>(), chaiscript::constructor<Entity(const Entity &)>() },
            {}
    );

    m->add(chaiscript::fun(&ECS::new_entity, &ecs_object), "new_entity");
    m->add(chaiscript::fun(&ECS::delete_entity, &ecs_object), "delete_entity");
    m->add(chaiscript::fun(&ECS::exists, &ecs_object), "entity_exists");

    // TODO: We can't easily add each component member to chai without writing them all out here.
    //       Consider moving chai initialization into an autogenerated function.

    // We can do a lot of component-specfic work in bulk using the pregenerated component X-Macro.
    #define X(ComponentT) \
    { \
        chaiscript::utility::add_class<ComponentT>( \
        *m, \
                std::string(#ComponentT) + "Component", \
                {chaiscript::constructor<ComponentT()>()}, \
                {} \
        ); \
        \
        using AddComponentFnPtrT = ComponentEntry<ComponentT> (ECS::*)(Entity, const ComponentT&); \
        m->add( \
                chaiscript::fun( \
                        static_cast<AddComponentFnPtrT>(&ECS::add_component<ComponentT>), &ecs_object), \
                "add_debug_name_component"); \
        using GetComponentFnPtrT = ComponentEntry<ComponentT> (ECS::*)(Entity); \
        m->add( \
                chaiscript::fun( \
                        static_cast<GetComponentFnPtrT>(&ECS::get_component<ComponentT>), &ecs_object), \
                "get_debug_name_component"); \
        /* Add entry class information */\
        chaiscript::utility::add_class<ComponentEntry<ComponentT>>(*m, \
            std::string(#ComponentT) + "ComponentEntry", \
                {}, \
                { \
                    {chaiscript::fun(&ComponentEntry<ComponentT>::entity), "entity" }, \
                    {chaiscript::fun(&ComponentEntry<ComponentT>::id), "id" }, \
                    {chaiscript::fun(&ComponentEntry<ComponentT>::value), "value" }, \
                    {chaiscript::fun(&ComponentEntry<ComponentT>::operator bool), "is_valid" }, \
                } \
            ); \
    }
    X_COMPONENTS
    #undef X

    chai.add(m);
}
