"""
codegen is a python script utility used to build codegen json files into C++ source code.
"""

import sys
import argparse
import json
import os

template_file_extension = ".json"
output_file_extension = ".hpp"
codegen_initial_comment = "//GENERATED"

# Templates for code generation.
prelude = """{}
// This file was auto-generated by the codegen utility. Do not edit (edits will be overwritten on when codegen is
// next ran - edit the corresponding template file ({}) instead).

#pragma once
"""

struct_template = """
struct {struct_name} {{
{members}
}};
"""


def make_namespaced(struct_body, namespace):
    """
    Add a namespace around a struct body.
    """
    if namespace == "":
        return struct_body
    return "namespace {namespace} {{\n{struct_body}}}\n".format(**locals())


def make_member(member):
    """
    Turn a member data entry into a C++ type declaration.
    """
    return "{} {};".format(member["type"], member["name"])


def generate_code(codegen_file):
    """
    Given a single codegen file template, generate and return the corresponding C++ code.
    """
    with open(codegen_file, 'r') as f:
        codegen_template = json.load(f)

    struct_name = codegen_template["name"]
    namespace = "" if "namespace" not in codegen_template else codegen_template["namespace"]
    if "data" in codegen_template:
        members = [make_member(m) for m in codegen_template["data"]]
        members = ["    {}".format(m) for m in members]
        members = "\n".join(members)
    else:
        members = ""

    struct_body = struct_template.format(
        struct_name=struct_name,
        members=members
    )

    if "include" in codegen_template:
        includes = "".join("#include <{}>\n".format(inc) for inc in codegen_template["include"])
    else:
        includes = ""

    code = (prelude.format(codegen_initial_comment, codegen_file)
            + includes
            + make_namespaced(struct_body, namespace))

    return {"struct_name": struct_name,
            "namespaced_struct_name": struct_name if namespace == "" else namespace + "::" + struct_name,
            "code": code,
            "xlisted": [] if "xlisted" not in codegen_template else codegen_template["xlisted"],
            "include_in": [] if "include_in" not in codegen_template else codegen_template["include_in"]}


def main():
    parser = argparse.ArgumentParser(description='Generate C++ code from .json template files')
    parser.add_argument(
        '--output', '-o', type=str, help='the directory to output files to')
    parser.add_argument(
        '--input', '-i', type=str, help='a directory to scan for input files')
    args = parser.parse_args()

    generated_files = []
    xlisted = {}
    includes = {}

    for root, dirs, files in os.walk(args.input):
        for file in files:
            if not file.endswith(template_file_extension):
                continue

            template_path = os.path.join(root, file).replace("\\", "/")
            output_path = os.path.join(args.output, os.path.relpath(root, args.input), file).replace("\\", "/")
            output_path = output_path.replace(template_file_extension, output_file_extension)

            if os.path.exists(output_path):
                with open(output_path, 'r') as f:
                    first_line = f.readline()
                    if not first_line.startswith(codegen_initial_comment):
                        print(("ERROR: Cannot create {} from {} because the file already exists and does not " +
                               "start with '{}'").format(output_path, template_path, codegen_initial_comment))
                        continue

            print("Generating file {} from {}".format(output_path, template_path))
            generated_file = generate_code(template_path)

            # Save file information to an x-list.
            for xlist in generated_file["xlisted"]:
                xlist_name = xlist[0]
                xlist_file_path = os.path.join(args.output, os.path.relpath(root, args.input), xlist[1]).replace("\\", "/")
                xlist_key = "{}:{}".format(xlist_file_path, xlist_name)
                if xlist_key not in xlisted:
                    xlisted[xlist_key] = {"entries": [], "listname": xlist_name, "fname": xlist_file_path}
                xlisted[xlist_key]["entries"].append(generated_file["namespaced_struct_name"])

            # save file information to an include list.
            for inc in generated_file["include_in"]:
                include_file_path = os.path.join(args.output, os.path.relpath(root, args.input), inc).replace("\\", "/")
                if include_file_path not in includes:
                    includes[include_file_path] = set()
                includes[include_file_path].add(output_path)

            # Ensure the path to the file-to-be-generated exists.
            if not os.path.exists(os.path.dirname(output_path)):
                os.makedirs(os.path.dirname(output_path))

            # Write the generated file
            with open(output_path, 'w+') as f:
                f.write(generated_file["code"])
            generated_files.append(output_path)

    # Generate x-list.
    for xlist_key, xlist in xlisted.items():
        xlist_code = """#define {} \\\n""".format(xlist["listname"])
        xlist_code = xlist_code + "\\\n".join(["    X({})".format(xentry) for xentry in xlist["entries"]])
        xlist_code = prelude.format(codegen_initial_comment, xlist["fname"]) + xlist_code

        # Make sure we only overwrite files that have been generated
        if os.path.exists(xlist["fname"]):
            with open(xlist["fname"], 'r') as f:
                first_line = f.readline()
                if not first_line.startswith(codegen_initial_comment):
                    print(("ERROR: Cannot create X-list file {} because the file already exists and does " +
                           "not start with '{}'").format(xlist["fname"], codegen_initial_comment))
                    continue

        print("Generating X-Macro list file {}".format(xlist["fname"]))
        with open(xlist["fname"], 'w+') as f:
            f.write(xlist_code)
        generated_files.append(xlist["fname"])

    # Generate files specified with include_in.
    for include_file, includes in includes.items():
        inc_code = ["#include \"{}\"".format(inc) for inc in includes]
        inc_code = "\n".join(inc_code)
        inc_code = prelude.format(codegen_initial_comment, include_file) + inc_code

        include_file = include_file.replace("\\", "/")

        # Make sure we only overwrite files that have been generated
        if os.path.exists(include_file):
            with open(include_file, 'r') as f:
                first_line = f.readline()
                if not first_line.startswith(codegen_initial_comment):
                    print(("ERROR: Cannot create include list file {} because the file already exists and does " +
                           "not start with '{}'").format(include_file, codegen_initial_comment))
                    continue

        print("Generating include list file {}".format(include_file))
        with open(include_file, 'w+') as f:
            f.write(inc_code)
        generated_files.append(include_file)

    # Generate CMakeLists.txt
    cmake_code = "SET(CYAN_GENERATED_SRC " + " ".join(generated_files) + ")\n"
    print("Generating CMakeLists.txt subdirectory file")
    with open(os.path.join(args.output, "CMakeLists.txt"), 'w+') as f:
        f.write(cmake_code)


if __name__ == '__main__':
    main()
