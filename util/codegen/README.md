cyanengine code generation
-
cyanengine uses code generation for some small data classes to simplify code editing. 
Code is generated by inputting the files into codegen.py.

    `python util/codegen.py -i {input-dir} -o {output-dir}`
    
e.g.

    `python util/codegen.py -i cyan/codegen/ -o cyan/generated/`
    
For each .json file in `cyan/codegen/`, this will create a corresponding `.hpp` file in
`cyan/generated/components`. This operation will occur on directories within `cyan/codegen`,
so if you have a codegen file `cyan/codegen/components/DebugName.json`, this will create a corresponding
`cyan/generated/components/DebugName.hpp`.

Codegen will also generate a CMakeLists file at the base of the output directory with the sole variable
`CYAN_GENERATED_SRC`. This allows to add the generated files to the CMake build script using
`include_directory({output-dir}`

If any files use the `xlisted` option, codegen will generate a file with an X-Macro of the struct names with the
specified name. If any files use the `include_in` option, codegen will generate a C++ header including the generated
file. Both these options will only work in a single directory - i.e. two files in the same directory with
`"include_in": "myfiles.hpp"` will result in `myfiles.hpp` being present in that directory including those two files.
If two files in different directories have `"include_in": "myfiles.hpp"`, two `myfiles.hpp` will be generated, one for
each directory, and those will include one file each.
  
codegen json specification
--
An appropriate codegen json file is as follows:

```
    // This example is for the cyan::component::DebugName component
    {
      // The namespace to place the generated struct into
      // Namespace is optional, and omitting it will cause the struct to be in the top-level namespace
      "namespace": "cyan::component",
      "name": "DebugName", // The name of the struct to make
      "data": [ // A list of JSON objects, ech one corresponding with a struct data member.
        {
          "name": "name", // The name of the member variable
          "type": "std::string"  // The type of the member variable
        },
        ... // more data
      ],
      // Optional: Place this struct's name into X-macro lists.
      "name-x-listed": [
        [ "X_COMPONENTS",      // The name of the X macro
          "components_x.hpp"   // The name of the file that will hold the X-macro
        ],
        ... // more X-macro lists can go here.
      ]
    }
```

motivation
---
Why does this exist? Every iteration of game engine with a wide number of 'component' and 'resource' objects has a
reoccurring problem with having to manually do work to add each (very simple) component into every corner of the ECS
system. This solves that problem by pre-generating the code along with X-Macros for lists of components. This allows
parts of the ECS code to automatically compile in new components by generating the component manipulation code before
compilation.